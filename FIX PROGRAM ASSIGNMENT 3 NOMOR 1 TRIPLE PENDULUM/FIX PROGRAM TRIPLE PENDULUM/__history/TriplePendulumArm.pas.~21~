unit TriplePendulumArm;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VclTee.TeeGDIPlus, Vcl.StdCtrls,
  Vcl.Samples.Spin, Vcl.Buttons, VCLTee.TeEngine, VCLTee.Series, Vcl.ExtCtrls,
  VCLTee.TeeProcs, VCLTee.Chart, opengl, math, Vcl.Grids, MotionEquationTriplePendulum;

type
  // Struktur Data untuk Parameter Sendi
  TJointParams = record
    c, k1, k2, k3, k4, phi1, phi2: Double;

    // Parameter Aktif (Target Trajectory)
    TargetAmp: Double;    // Amplitudo gerakan target (Rad)
    TargetFreq: Double;   // Frekuensi (Hz)
    TargetPhase: Double;  // Fasa (untuk delay antar sendi)
    TargetOffset: Double; // Titik tengah gerakan (Rad)

    // Parameter Kontroler PD (Kekuatan Otot mengejar target)
    Kp: Double; // Stiffness (Kekakuan mengejar posisi)
    Kd: Double; // Damping (Peredam kecepatan)
  end;

  // Struktur Data untuk Segmen Tubuh
  TSegmentData = record
    m, l, a, I_inert: Double; // Massa, Panjang, Jarak COM, Inersia
  end;

  TForm1 = class(TForm)
    Timer1: TTimer;
    ScrollBox1: TScrollBox;
    ChartElbow: TChart;
    SeriesElbow: TLineSeries;
    ChartShoulder: TChart;
    SeriesShoulder: TLineSeries;
    ChartWrist: TChart;
    SeriesWrist: TLineSeries;
    LabelAxisX: TLabel;
    LabelAxisY: TLabel;
    LabelAxisZ: TLabel;
    LabelPitch: TLabel;
    LabelRoll: TLabel;
    LabelYaw: TLabel;
    PanelControl: TPanel;
    BitBtnRun: TBitBtn;
    BitBtnStop: TBitBtn;
    BitBtnClose: TBitBtn;
    GroupBoxAntro: TGroupBox;
    LabelBW: TLabel;
    LabelBH: TLabel;
    edBW: TEdit;
    edBH: TEdit;
    GroupBoxShoulder: TGroupBox;
    LabelS_c: TLabel;
    LabelS_k1: TLabel;
    LabelS_k2: TLabel;
    LabelS_p1: TLabel;
    LabelS_k3: TLabel;
    LabelS_k4: TLabel;
    LabelS_p2: TLabel;
    edS_c: TEdit;
    edS_k1: TEdit;
    edS_k2: TEdit;
    edS_p1: TEdit;
    edS_k3: TEdit;
    edS_k4: TEdit;
    edS_p2: TEdit;
    GroupBoxElbow: TGroupBox;
    LabelE_c: TLabel;
    LabelE_k1: TLabel;
    LabelE_k2: TLabel;
    LabelE_p1: TLabel;
    LabelE_k3: TLabel;
    LabelE_k4: TLabel;
    LabelE_p2: TLabel;
    edE_c: TEdit;
    edE_k1: TEdit;
    edE_k2: TEdit;
    edE_p1: TEdit;
    edE_k3: TEdit;
    edE_k4: TEdit;
    edE_p2: TEdit;
    GroupBoxWrist: TGroupBox;
    LabelW_c: TLabel;
    LabelW_k1: TLabel;
    LabelW_k2: TLabel;
    LabelW_p1: TLabel;
    LabelW_k3: TLabel;
    LabelW_k4: TLabel;
    LabelW_p2: TLabel;
    edW_c: TEdit;
    edW_k1: TEdit;
    edW_k2: TEdit;
    edW_p1: TEdit;
    edW_k3: TEdit;
    edW_k4: TEdit;
    edW_p2: TEdit;
    GroupBoxInit: TGroupBox;
    LabelInit1: TLabel;
    LabelInit2: TLabel;
    LabelInit3: TLabel;
    edInitSh: TEdit;
    edInitEl: TEdit;
    edInitWr: TEdit;
    GroupBoxMatrix: TGroupBox;
    GridMatrix: TStringGrid;
    ButtonMotionEquationFig: TButton;
    PanelGL: TPanel;
    sePitch: TSpinEdit;
    seRoll: TSpinEdit;
    seYaw: TSpinEdit;
    BitBtnPassive: TBitBtn;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure PanelGLResize(Sender: TObject);

    procedure BitBtnRunClick(Sender: TObject);
    procedure BitBtnStopClick(Sender: TObject);
    procedure BitBtnCloseClick(Sender: TObject);

    procedure Timer1Timer(Sender: TObject);

    procedure seYawChange(Sender: TObject);
    procedure sePitchChange(Sender: TObject);
    procedure seRollChange(Sender: TObject);
    procedure ButtonMotionEquationFigClick(Sender: TObject);
    procedure BitBtnPassiveClick(Sender: TObject);

  private
    myDC : HDC;
    myRC : HGLRC;

    // State Variables (1=Shoulder, 2=Elbow, 3=Wrist)
    // Sudut (Radian), Kecepatan Sudut (Rad/s), Percepatan Sudut (Rad/s^2)
    th1, th2, th3 : Double;
    dth1, dth2, dth3 : Double;
    ddth1, ddth2, ddth3 : Double;

    // Anthropometry Data
    SegArm, SegForearm, SegHand : TSegmentData;

    // Joint Parameters
    ParamSh, ParamEl, ParamWr : TJointParams;

    // Simulation Time
    SimTime, dt : Double;

    // Camera Vars
    xpos, ypos, zpos, yaw, pitch, roll : Double;
    Sphere, Cylinder : GLUquadricObj;

    // --- Physics Procedures ---
    procedure CalculateAnthropometry;
    function ComputePassiveTorque(theta, dtheta: Double; p: TJointParams): Double;
    function ComputeActiveTorque(SimTime, th, dth: Double; p: TJointParams): Double;
    procedure ComputeMotionEquation; // Lagrangian Dynamics
    procedure SolveCramer(
      M11, M12, M13,
      M21, M22, M23,
      M31, M32, M33,
      R1, R2, R3 : Double;
      out res1, res2, res3 : Double);

    // --- Helper ---
    function ReadVal(E: TEdit; Def: Double): Double;
    procedure SetupPixelFormat;
    procedure RenderScene;
    procedure DrawBox(w, h, d: GLfloat);
    procedure DrawAxis(Length: Single);
    procedure UpdateCharts;
    procedure UpdateMatrixGrid(M: array of Double);

  public
    { Public declarations }
  end;

var
  Form1: TForm1;

  // OpenGL Lighting
  mat_specular : array [0..3] of GLfloat = ( 0.2, 0.2, 0.2, 1.0 );
  mat_shininess : GLfloat = 10.0;
  light_position : array [0..3] of GLfloat = ( 50.0, 50.0, 50.0, 1.0 );

implementation

{$R *.dfm}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function TForm1.ReadVal(E: TEdit; Def: Double): Double;
begin
  try
    Result := StrToFloat(StringReplace(E.Text, ',', '.', [rfReplaceAll]));
  except
    Result := Def;
  end;
end;

// ============================================================================
// PHYSICS ENGINE: LAGRANGIAN DYNAMICS (TRIPLE PENDULUM)
// ============================================================================

// 1. Hitung Massa & Inersia berdasarkan Tabel Regresi (PDF Halaman 1)
procedure TForm1.CalculateAnthropometry;
var
  BW, BH: Double;
  r1, r2, r3: Double; // Radius Girasi
begin
  BW := ReadVal(edBW, 70.0);
  BH := ReadVal(edBH, 1.72); // Meter

  // Segmen 1: Lengan Atas (Arm)
  SegArm.m := 0.028 * BW;
  SegArm.l := 0.172 * BH;
  SegArm.a := 0.436 * SegArm.l;      // Jarak COM dari Shoulder
  r1       := 0.322 * SegArm.l;      // Radius Girasi
  SegArm.I_inert := SegArm.m * Sqr(r1);

  // Segmen 2: Lengan Bawah (Forearm)
  SegForearm.m := 0.016 * BW;
  SegForearm.l := 0.157 * BH;
  SegForearm.a := 0.430 * SegForearm.l; // Jarak COM dari Elbow
  r2           := 0.303 * SegForearm.l;
  SegForearm.I_inert := SegForearm.m * Sqr(r2);

  // Segmen 3: Tangan (Hand)
  SegHand.m := 0.006 * BW;
  SegHand.l := 0.0575 * BH;
  SegHand.a := 0.494 * SegHand.l;
  r3        := 0.297 * SegHand.l;
  SegHand.I_inert := SegHand.m * Sqr(r3);
end;

// 2. Hitung Torsi Active dan Pasif
function TForm1.ComputePassiveTorque(theta, dtheta: Double; p: TJointParams): Double;
var
  thDeg: Double;
  PasTorque: Double;
begin
  thDeg := RadToDeg(theta);

  Result := -p.c * dtheta
            + p.k1 * Exp(-p.k2 * (thDeg - p.phi1))
            + p.k3 * Exp( p.k4 * (thDeg - p.phi2));
  // --- SAFETY CLAMP (PENTING UNTUK MENCEGAH NAN) ---
  // Jika gaya pegas eksponensial terlalu kuat, batasi di +/- 500 Nm
  if PasTorque > 500 then PasTorque := 500
  else if PasTorque < -500 then PasTorque := -500;

  Result := PasTorque;
end;

function TForm1.ComputeActiveTorque(SimTime, th, dth: Double; p: TJointParams): Double;
var
  TargetPos, TargetVel: Double;
  ErrorPos, ErrorVel: Double;
  Omega: Double;
  CalculatedTorque: Double;
begin
  // Jika target amplitudo 0, tetap berikan sedikit "stiffness" agar sendi tidak loyo (seperti mayat)
  // Tapi untuk simulasi ini, kita fokus ke target gerak.

  Omega := 2 * Pi * p.TargetFreq;

  // 1. Hitung Posisi & Kecepatan Target
  TargetPos := p.TargetOffset + p.TargetAmp * Sin(Omega * SimTime + p.TargetPhase);
  TargetVel := p.TargetAmp * Omega * Cos(Omega * SimTime + p.TargetPhase);

  // 2. Hitung Error
  ErrorPos := TargetPos - th;
  ErrorVel := TargetVel - dth;

  // 3. Hitung Torsi PD (Otot)
  // Perhatikan: Kita pakai local variable dulu
  CalculatedTorque := (p.Kp * ErrorPos) + (p.Kd * ErrorVel);

  // 4. SAFETY CLAMP (MENCEGAH NaN)
  // Batas 50 Nm sudah sangat kuat untuk lengan manusia.
  if CalculatedTorque > 50.0 then CalculatedTorque := 50.0
  else if CalculatedTorque < -50.0 then CalculatedTorque := -50.0;

  Result := CalculatedTorque;
end;

// 3. Solver Sistem Persamaan Linear 3x3 (Cramer's Rule)
procedure TForm1.SolveCramer(
  M11, M12, M13,
  M21, M22, M23,
  M31, M32, M33,
  R1, R2, R3 : Double;
  out res1, res2, res3 : Double);
var
  DetM, Det1, Det2, Det3: Double;
begin
  // Determinan Utama
  DetM := M11*(M22*M33 - M23*M32) -
          M12*(M21*M33 - M23*M31) +
          M13*(M21*M32 - M22*M31);

  if Abs(DetM) < 1e-9 then DetM := 1e-9; // Cegah div by zero

  // Determinan 1 (Ganti Kolom 1 dengan R)
  Det1 := R1 *(M22*M33 - M23*M32) -
          M12*(R2 *M33 - M23*R3 ) +
          M13*(R2 *M32 - M22*R3 );

  // Determinan 2 (Ganti Kolom 2 dengan R)
  Det2 := M11*(R2 *M33 - M23*R3 ) -
          R1 *(M21*M33 - M23*M31) +
          M13*(M21*R3  - R2 *M31);

  // Determinan 3 (Ganti Kolom 3 dengan R)
  Det3 := M11*(M22*R3  - R2 *M32) -
          M12*(M21*R3  - R2 *M31) +
          R1 *(M21*M32 - M22*M31);

  res1 := Det1 / DetM;
  res2 := Det2 / DetM;
  res3 := Det3 / DetM;
end;

// 4. Inti Perhitungan Motion Equation (PDF Halaman 4)
procedure TForm1.ComputeMotionEquation;
var
  // Constants Coefficients (K11, K22, etc from PDF Page 2)
  K11, K22, K33, K12, K13, K23: Double;
  G_coeff1, G_coeff2, G_coeff3: Double;
  g_grav: Double;

  // Matrix Components
  M11, M12, M13, M21, M22, M23, M31, M32, M33: Double;
  V1, V2, V3: Double; // Coriolis & Centrifugal Vector
  G1, G2, G3: Double; // Gravity Vector
  Tau1, Tau2, Tau3, TauPassive1, TauPassive2, TauPassive3, TauActive1, TauActive2, TauActive3: Double; // Torque Vector

  // Trigonometry Cache
  c12, c13, c23: Double; // cos(th1-th2), etc
  s12, s13, s23: Double; // sin(th1-th2), etc
  s1, s2, s3: Double;

  RHS1, RHS2, RHS3: Double; // Right Hand Side = Tau - V - G
begin
  g_grav := 9.81;

  // Pre-calculate Trigonometry
  c12 := Cos(th1 - th2);
  c13 := Cos(th1 - th3);
  c23 := Cos(th2 - th3);

  s12 := Sin(th1 - th2);
  s13 := Sin(th1 - th3);
  s23 := Sin(th2 - th3);

  s1 := Sin(th1);
  s2 := Sin(th2);
  s3 := Sin(th3);

  // --- Calculate Definition Coefficients (PDF Page 2) ---
  // K11 = I1 + m1*a1^2 + (m2+m3)*l1^2
  K11 := SegArm.I_inert + SegArm.m*Sqr(SegArm.a) + (SegForearm.m + SegHand.m)*Sqr(SegArm.l);

  // K22 = I2 + m2*a2^2 + m3*l2^2
  K22 := SegForearm.I_inert + SegForearm.m*Sqr(SegForearm.a) + SegHand.m*Sqr(SegForearm.l);

  // K33 = I3 + m3*a3^2
  K33 := SegHand.I_inert + SegHand.m*Sqr(SegHand.a);

  // Coupling Constants
  K12 := SegArm.l * (SegForearm.m*SegForearm.a + SegHand.m*SegForearm.l);
  K13 := SegHand.m * SegArm.l * SegHand.a;
  K23 := SegHand.m * SegForearm.l * SegHand.a;

  // Gravity Constants
  G_coeff1 := g_grav * (SegArm.m*SegArm.a + SegForearm.m*SegArm.l + SegHand.m*SegArm.l);
  G_coeff2 := g_grav * (SegForearm.m*SegForearm.a + SegHand.m*SegForearm.l);
  G_coeff3 := g_grav * (SegHand.m*SegHand.a);

  // --- 1. Inertia Matrix M (PDF Page 3) ---
  M11 := K11;
  M12 := K12 * c12;  M21 := M12;
  M13 := K13 * c13;  M31 := M13;
  M22 := K22;
  M23 := K23 * c23;  M32 := M23;
  M33 := K33;

  // Update StringGrid with Matrix M values
  UpdateMatrixGrid([M11, M12, M13, M21, M22, M23, M31, M32, M33]);

  // --- 2. Coriolis & Centrifugal Vector V (PDF Page 4) ---
  // V1 = K12*sin(1-2)*dth2^2 + K13*sin(1-3)*dth3^2
  V1 := K12*s12*Sqr(dth2) + K13*s13*Sqr(dth3);

  // V2 = -K12*sin(1-2)*dth1^2 + K23*sin(2-3)*dth3^2
  V2 := -K12*s12*Sqr(dth1) + K23*s23*Sqr(dth3);

  // V3 = -K13*sin(1-3)*dth1^2 - K23*sin(2-3)*dth2^2
  V3 := -K13*s13*Sqr(dth1) - K23*s23*Sqr(dth2);

  // --- 3. Gravitational Vector G (PDF Page 4) ---
  G1 := G_coeff1 * s1;
  G2 := G_coeff2 * s2;
  G3 := G_coeff3 * s3;

  // --- 4. Torque Vector Tau (Active + Passive) ---
  // Hitung Torsi Pasif (Gesekan + Ligamen)
  TauPassive1 := ComputePassiveTorque(th1, dth1, ParamSh);
  TauPassive2 := ComputePassiveTorque(th2, dth2, ParamEl);
  TauPassive3 := ComputePassiveTorque(th3, dth3, ParamWr);

  // Hitung Torsi Aktif (Otot / Motor)
  TauActive1 := ComputeActiveTorque(SimTime, th1, dth1, ParamSh);
  TauActive2 := ComputeActiveTorque(SimTime, th2, dth2, ParamEl);
  TauActive3 := ComputeActiveTorque(SimTime, th3, dth3, ParamWr);

  Tau1 := TauPassive1 + TauActive1;
  Tau2 := TauPassive2 + TauActive2;
  Tau3 := TauPassive3 + TauActive3;

  // --- 5. Formulate Linear System for Accelerations ---
  // M * ddth = Tau - V - G
  RHS1 := Tau1 - V1 - G1;
  RHS2 := Tau2 - V2 - G2;
  RHS3 := Tau3 - V3 - G3;

  // --- 6. Solve for ddth ---
  SolveCramer(
    M11, M12, M13,
    M21, M22, M23,
    M31, M32, M33,
    RHS1, RHS2, RHS3,
    ddth1, ddth2, ddth3
  );
end;

procedure TForm1.Timer1Timer(Sender: TObject);
begin
  // Hitung Percepatan (Lagrangian Dynamics)
  ComputeMotionEquation;

  // Integrasi Numerik (Semi-Implicit Euler)
  // Kecepatan Baru
  dth1 := dth1 + ddth1 * dt;
  dth2 := dth2 + ddth2 * dt;
  dth3 := dth3 + ddth3 * dt;

  // Posisi Baru
  th1 := th1 + dth1 * dt;
  th2 := th2 + dth2 * dt;
  th3 := th3 + dth3 * dt;

  // Update Visual & Grafik
  SimTime := SimTime + dt;
  UpdateCharts;
  RenderScene;
end;

// ============================================================================
// VISUALIZATION & GUI HANDLING
// ============================================================================

procedure TForm1.RenderScene;
var
  vL1, vL2, vL3: Double;
  angleElbow, angleWrist: Double;
  radShoulder, radElbow, radWrist: Double;

  // Variabel untuk Jari
  i: Integer;
  fingerLen, fingerWidth: Double;
  thumbLen: Double;
  HandScale: Double;

  // Variabel Animasi Jari Lokal (Untuk pose rileks)
  rotangle1, rotangle2, rotangle3: Double;
begin
  if (myDC = 0) or (myRC = 0) then Exit;
  wglMakeCurrent(myDC, myRC);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadIdentity;

  // --- 1. KAMERA & AXIS ---
  glTranslate(xpos, ypos, zpos);
  glRotate(pitch, 1, 0, 0);
  glRotate(yaw, 0, 1, 0);
  glRotate(roll, 0, 0, 1);

  DrawAxis(4.0); // Compass

  // --- 2. SCALING & SETUP ---
  vL1 := SegArm.l * 10;
  vL2 := SegForearm.l * 10;
  vL3 := SegHand.l * 10;

  radShoulder := 0.75;
  radElbow := 0.55;
  radWrist := 0.40;

  // Set Pose Jari (Rileks / Semi-Clenched)
  rotangle1 := 20.0;
  rotangle2 := 30.0;
  rotangle3 := 10.0;

  glColor3f(0.75, 0.75, 0.75); // Skin Tone

  // ==========================================
  // SEGMENT 1: UPPER ARM (BAHU)
  // ==========================================
  glPushMatrix();
    gluSphere(Sphere, radShoulder * 1.1, 32, 32); // Sendi Bahu

    // Rotasi Bahu (th1) + Offset 90 derajat agar 0 = Lurus ke Bawah
    glRotate(RadToDeg(th1) + 90, 1, 0, 0);

    gluCylinder(Cylinder, radShoulder, radElbow, vL1, 32, 32);

    // ==========================================
    // SEGMENT 2: FOREARM (SIKU)
    // ==========================================
    glTranslate(0, 0, vL1); // Pindah ke ujung Upper Arm
    gluSphere(Sphere, radElbow * 1.0, 32, 32); // Sendi Siku

    // Rotasi Siku Relatif (th2 - th1)
    angleElbow := RadToDeg(th2 - th1);
    // Constraint visual agar siku tidak patah terbalik
    if angleElbow < 0 then angleElbow := 0;

    glRotate(angleElbow, 1, 0, 0);

    gluCylinder(Cylinder, radElbow, radWrist, vL2, 32, 32);

    // ==========================================
    // SEGMENT 3: HAND (WRIST & FINGERS)
    // ==========================================
    glTranslate(0, 0, vL2); // Pindah ke ujung Forearm
    gluSphere(Sphere, radWrist, 24, 24); // Sendi Wrist

    // Rotasi Wrist Relatif (th3 - th2)
    angleWrist := RadToDeg(th3 - th2);
    glRotate(angleWrist, 1, 0, 0);

    glPushMatrix();

      // 1. Orientasi Telapak Tangan
      // Agar telapak menghadap ke Medial (Paha) saat lurus
      glRotate(-90, 0, 0, 1);

      // 2. Scaling Jari
      if vL3 > 0.1 then
        HandScale := (vL3 * 1.9) / 2.4
      else
        HandScale := 1.0;

      glScalef(HandScale, HandScale, HandScale);

      // 3. Telapak Tangan (Palm)
      glPushMatrix();
        glTranslate(0, 0, 1.2); // Geser ke tengah telapak (relatif thd skala 2.4)
        DrawBox(1.2, 0.5, 2.4);
      glPopMatrix();

      // 4. Jari-Jari (Telunjuk s/d Kelingking)
      fingerWidth := 0.24;
      for i := 0 to 3 do
      begin
        glPushMatrix();
          // Offset posisi antar jari
          glTranslate((0.33 - (i * fingerWidth)), 0, 2.4);

          // Variasi Panjang Jari
          if i = 1 then fingerLen := 1.6       // Tengah
          else if i = 3 then fingerLen := 1.1  // Kelingking
          else fingerLen := 1.4;               // Telunjuk & Manis

          // Animasi Ruas 1
          glRotate(rotangle1, 1, 0, 0);
          gluCylinder(Cylinder, 0.11, 0.10, fingerLen * 0.5, 12, 4);
          glTranslate(0, 0, fingerLen * 0.5);
          gluSphere(Sphere, 0.10, 8, 8);

          // Animasi Ruas 2
          glRotate(rotangle2 * 0.8, 1, 0, 0);
          gluCylinder(Cylinder, 0.10, 0.09, fingerLen * 0.3, 12, 4);
          glTranslate(0, 0, fingerLen * 0.3);
          gluSphere(Sphere, 0.09, 8, 8);

          // Animasi Ruas 3 (Ujung)
          glRotate(rotangle3 * 0.5, 1, 0, 0);
          gluCylinder(Cylinder, 0.09, 0.08, fingerLen * 0.2, 12, 4);
          glTranslate(0, 0, fingerLen * 0.2);
          gluSphere(Sphere, 0.08, 8, 8);
        glPopMatrix();
      end;

      // 5. Ibu Jari (Thumb)
      glPushMatrix();
        glTranslate(0.7, 0, 0.8); // Posisi pangkal
        glRotate(50, 0, 1, 0);    // Abduksi
        glRotate(20, 0, 0, 1);    // Oposisi

        glRotate(rotangle1 * 0.5, 1, 0, 0); // Animasi Thumb

        thumbLen := 1.2;

        // Metacarpal
        gluCylinder(Cylinder, 0.14, 0.12, thumbLen * 0.4, 12, 4);
        glTranslate(0, 0, thumbLen * 0.4);
        gluSphere(Sphere, 0.12, 8, 8);

        // Proximal
        glRotate(rotangle2 * 0.5, 1, 0, 0);
        gluCylinder(Cylinder, 0.12, 0.10, thumbLen * 0.35, 12, 4);
        glTranslate(0, 0, thumbLen * 0.35);
        gluSphere(Sphere, 0.10, 8, 8);

        // Distal
        glRotate(rotangle3 * 0.5, 1, 0, 0);
        gluCylinder(Cylinder, 0.10, 0.09, thumbLen * 0.25, 12, 4);
        glTranslate(0, 0, thumbLen * 0.25);
        gluSphere(Sphere, 0.09, 8, 8);
      glPopMatrix();

    glPopMatrix(); // Selesai Blok Tangan

  glPopMatrix(); // Selesai Blok Keseluruhan

  SwapBuffers(myDC);
end;

procedure TForm1.BitBtnPassiveClick(Sender: TObject);
begin
  // 1. Hitung Data Antropometri
  CalculateAnthropometry;

  // 2. SETUP PARAMETER PASIF (GRAVITASI + LIMITER/LIGAMEN)

  // --- SHOULDER ---
  // Range Normal: Ekstensi (-50) s/d Fleksi (150)
  ParamSh.c  := 3.0;      // Damping cukup besar agar bahu tidak berayun selamanya
  ParamSh.k1 := 1.5;      // Stiffness limit ekstensi diperkuat
  ParamSh.k2 := 0.5;      // Gradien eksponensial
  ParamSh.k3 := 0.5;
  ParamSh.k4 := 0.5;
  ParamSh.phi1 := -15.0;  // Batas belakang (agar bisa diam di 0 tanpa terdorong)
  ParamSh.phi2 := 120.0;  // Batas depan

  // MATIKAN Active Torque
  ParamSh.TargetFreq   := 0;
  ParamSh.TargetAmp    := 0;
  ParamSh.TargetOffset := 0;
  ParamSh.Kp := 0.0;
  ParamSh.Kd := 0.0;

  // --- ELBOW ---
  // Range Normal: 0 (Lurus) s/d 145 (Tekuk Penuh)
  // Penting: phi1 diset sedikit negatif (-10) agar posisi 0 (lurus)
  // adalah zona bebas hambatan. Jika diset 0 pas, pegas akan terus mendorong
  // lengan sedikit menekuk.
  ParamEl.c  := 2.0;      // Damping moderat
  ParamEl.k1 := 2.0;     // Stiffness SANGAT KUAT untuk mencegah hyperextension negatif
  ParamEl.k2 := 1.0;      // Respon cepat saat mendekati batas
  ParamEl.k3 := 0.1;
  ParamEl.k4 := 0.5;
  ParamEl.phi1 := -10.0;  // "Tembok" batas bawah di -10 derajat (toleransi momentum)
  ParamEl.phi2 := 130.0;  // Batas atas tekukan

  // MATIKAN Active Torque
  ParamEl.TargetFreq   := 0;
  ParamEl.TargetAmp    := 0;
  ParamEl.TargetOffset := 0;
  ParamEl.Kp := 0.0;
  ParamEl.Kd := 0.0;

  // --- WRIST ---
  // Range Normal: Ekstensi (-70) s/d Fleksi (80)
  ParamWr.c  := 0.5;      // Damping ringan (tangan mudah goyang)
  ParamWr.k1 := 1.0;
  ParamWr.k2 := 0.5;
  ParamWr.k3 := 1.0;
  ParamWr.k4 := 0.5;
  ParamWr.phi1 := -30.0;  // Batas ekstensi pergelangan
  ParamWr.phi2 := 60.0;   // Batas fleksi pergelangan

  // MATIKAN Active Torque
  ParamWr.TargetFreq   := 0;
  ParamWr.TargetAmp    := 0;
  ParamWr.TargetOffset := 0;
  ParamWr.Kp := 0.0;
  ParamWr.Kd := 0.0;

  // 3. SET KONDISI AWAL (INITIAL CONDITIONS)
  // Mengambil nilai dari komponen Edit (Derajat) lalu konversi ke Radian
  th1 := DegToRad(ReadVal(edInitSh, 45)); // Misal drop dari 45 derajat
  th2 := DegToRad(ReadVal(edInitEl, 45));
  th3 := DegToRad(ReadVal(edInitWr, 0));

  // Kecepatan awal nol
  dth1 := 0;
  dth2 := 0;
  dth3 := 0;

  // Reset Waktu & Step
  SimTime := 0;
  dt := 0.002;

  // 4. Bersihkan Grafik & Mulai Timer
  SeriesShoulder.Clear;
  SeriesElbow.Clear;
  SeriesWrist.Clear;

  Timer1.Interval := 2;
  Timer1.Enabled := True;
end;

procedure TForm1.BitBtnRunClick(Sender: TObject);
begin
  // 1. Baca Antropometri
  CalculateAnthropometry;

  // 2. SETUP PARAMETER (Sesuai Logika Wave Motion)

  // --- SHOULDER
  ParamSh.c := 0.5;
  ParamSh.k1 := 0.1;
  ParamSh.k2 := 0.5;
  ParamSh.k3 := 0.1;
  ParamSh.k4 := 0.5;
  ParamSh.phi1 := -45;
  ParamSh.phi2 := 120;

  // Target Gerak Bahu
  ParamSh.TargetFreq   := 1.0;
  ParamSh.TargetOffset := DegToRad(10); // Titik tengah sedikit ke depan
  ParamSh.TargetAmp    := DegToRad(35);
  ParamSh.TargetPhase  := 0;

  // KONTROL PD BAHU
  ParamSh.Kp := 40.0;
  ParamSh.Kd := 4.0;

  // --- ELBOW ---
  ParamEl.c := 0.2;
  ParamEl.k1 := 0.1;
  ParamEl.k2 := 0.5;
  ParamEl.k3 := 0.1;
  ParamEl.k4 := 0.5;
  ParamEl.phi1 := 0;
  ParamEl.phi2 := 140;

  // Target Gerak Siku
  ParamEl.TargetFreq   := 1.0;
  ParamEl.TargetOffset := DegToRad(25); // Natural position agak menekuk
  ParamEl.TargetAmp    := DegToRad(20);
  ParamEl.TargetPhase  := DegToRad(-30);

  // KONTROL PD SIKU
  ParamEl.Kp := 20.0;
  ParamEl.Kd := 2.0;

  // --- WRIST ---
  ParamWr.c := 0.05;
  ParamWr.k1 := 0.01;
  ParamWr.k2 := 0.5;
  ParamWr.k3 := 0.01;
  ParamWr.k4 := 0.5;
  ParamWr.phi1 := 0;
  ParamWr.phi2 := 60;

  // Target Gerak Wrist
  ParamWr.TargetFreq   := 1.0;
  ParamWr.TargetOffset := DegToRad(25);
  ParamWr.TargetAmp    := DegToRad(30);  // Gerakan kecil saja
  ParamWr.TargetPhase  := DegToRad(-60);

  // KONTROL PD WRIST
  ParamWr.Kp := 8.0;
  ParamWr.Kd := 0.5;

  // 3. Set Kondisi Awal (Mulai dari posisi target agar tidak tersentak)
  th1 := ParamSh.TargetOffset;
  th2 := ParamEl.TargetOffset;
  th3 := ParamWr.TargetOffset;

  dth1 := 0; dth2 := 0; dth3 := 0;
  SimTime := 0;

  // Time step
  dt := 0.002;

  SeriesShoulder.Clear; SeriesElbow.Clear; SeriesWrist.Clear;
  Timer1.Interval := 2;
  Timer1.Enabled := True;
end;

procedure TForm1.BitBtnStopClick(Sender: TObject);
begin
  Timer1.Enabled := False;
end;

procedure TForm1.ButtonMotionEquationFigClick(Sender: TObject);
begin
  if Assigned(Form2) then
    Form2.Show;
end;

procedure TForm1.BitBtnCloseClick(Sender: TObject);
begin
  Close;
end;

procedure TForm1.UpdateCharts;
begin
  // Plotting Sudut dalam Derajat
  SeriesShoulder.AddXY(SimTime, RadToDeg(th1));
  SeriesElbow.AddXY(SimTime, RadToDeg(th2));
  SeriesWrist.AddXY(SimTime, RadToDeg(th3));
end;

procedure TForm1.UpdateMatrixGrid(M: array of Double);
var r, c: Integer;
begin
  // Grid 3x3 (plus header)
  // Input array flat: M11, M12, M13, M21...
  for r := 0 to 2 do
    for c := 0 to 2 do
      GridMatrix.Cells[c+1, r+1] := FormatFloat('0.000', M[r*3 + c]);
end;

procedure TForm1.DrawAxis(Length: Single);
begin
  glDisable(GL_LIGHTING);
  glLineWidth(2.0);
  glBegin(GL_LINES);
    // X Axis - Merah (Posterior/Anterior)
    glColor3f(1.0, 0.0, 0.0);
    glVertex3f(0, 0, -Length);
    glVertex3f(0, 0, Length);
    // Y Axis - Hijau (Medial/Lateral)
    glColor3f(0.0, 1.0, 0.0);
    glVertex3f(-Length, 0, 0);
    glVertex3f(Length, 0, 0);
    // Z Axis - Biru (Inferior/Superior)
    glColor3f(0.0, 0.0, 1.0);
    glVertex3f(0, -Length, 0);
    glVertex3f(0, Length, 0);
  glEnd;
  glEnable(GL_LIGHTING);
end;

procedure TForm1.DrawBox(w, h, d: GLfloat);
begin
  glPushMatrix;
  glScalef(w, h, d);
  glBegin(GL_QUADS);
    // Depan
    glNormal3f(0, 0, 1);
    glVertex3f(-0.5, -0.5, 0.5);
    glVertex3f(0.5, -0.5, 0.5);
    glVertex3f(0.5, 0.5, 0.5);
    glVertex3f(-0.5, 0.5, 0.5);
    // Belakang
    glNormal3f(0, 0, -1);
    glVertex3f(-0.5, -0.5, -0.5);
    glVertex3f(-0.5, 0.5, -0.5);
    glVertex3f(0.5, 0.5, -0.5);
    glVertex3f(0.5, -0.5, -0.5);
    // Atas
    glNormal3f(0, 1, 0);
    glVertex3f(-0.5, 0.5, -0.5);
    glVertex3f(-0.5, 0.5, 0.5);
    glVertex3f(0.5, 0.5, 0.5);
    glVertex3f(0.5, 0.5, -0.5);
    // Bawah
    glNormal3f(0, -1, 0);
    glVertex3f(-0.5, -0.5, -0.5);
    glVertex3f(0.5, -0.5, -0.5);
    glVertex3f(0.5, -0.5, 0.5);
    glVertex3f(-0.5, -0.5, 0.5);
    // Kanan
    glNormal3f(1, 0, 0);
    glVertex3f(0.5, -0.5, -0.5);
    glVertex3f(0.5, 0.5, -0.5);
    glVertex3f(0.5, 0.5, 0.5);
    glVertex3f(0.5, -0.5, 0.5);
    // Kiri
    glNormal3f(-1, 0, 0);
    glVertex3f(-0.5, -0.5, -0.5);
    glVertex3f(-0.5, -0.5, 0.5);
    glVertex3f(-0.5, 0.5, 0.5);
    glVertex3f(-0.5, 0.5, -0.5);
  glEnd;
  glPopMatrix;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  // Camera Init
  yaw := 30;
  pitch := 0;
  roll := 0;

  xpos := 0;
  ypos := 3.5;
  zpos := -22;

  // StringGrid Setup
  GridMatrix.Cells[0,0] := 'M';
  GridMatrix.Cells[1,0] := '1';
  GridMatrix.Cells[2,0] := '2';
  GridMatrix.Cells[3,0] := '3';
  GridMatrix.Cells[0,1] := '1';
  GridMatrix.Cells[0,2] := '2';
  GridMatrix.Cells[0,3] := '3';

  // OpenGL Init
  myDC := GetDC(PanelGL.Handle);
  SetupPixelFormat;
  myRC := wglCreateContext(myDC);
  wglMakeCurrent(myDC, myRC);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_COLOR_MATERIAL);

  glMaterialfv(GL_FRONT, GL_SPECULAR, @mat_specular);
  glMaterialfv(GL_FRONT, GL_SHININESS, @mat_shininess);
  glLightfv(GL_LIGHT0, GL_POSITION, @light_position);

  Sphere := gluNewQuadric();
  Cylinder := gluNewQuadric();

  FormResize(nil);
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
  Timer1.Enabled := False;
  wglMakeCurrent(0,0);
  wglDeleteContext(myRC);
  ReleaseDC(PanelGL.Handle, myDC);
end;

procedure TForm1.FormResize(Sender: TObject);
begin
  if (myDC = 0) then Exit;
  wglMakeCurrent(myDC, myRC);
  glViewport(0, 0, PanelGL.Width, PanelGL.Height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0, PanelGL.Width / PanelGL.Height, 1, 200.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
end;

procedure TForm1.PanelGLResize(Sender: TObject);
begin
  FormResize(Sender);
end;

procedure TForm1.SetupPixelFormat;
var nPixelFormat: Integer; pfd: TPixelFormatDescriptor;
begin
  FillChar(pfd, SizeOf(pfd), 0);
  pfd.nSize := sizeof(pfd);
  pfd.nVersion := 1;
  pfd.dwFlags := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
  pfd.iPixelType := PFD_TYPE_RGBA;
  pfd.cColorBits := 32;
  pfd.cDepthBits := 32;
  pfd.iLayerType := PFD_MAIN_PLANE;
  nPixelFormat := ChoosePixelFormat(myDC, @pfd);
  SetPixelFormat(myDC, nPixelFormat, @pfd);
end;

procedure TForm1.seYawChange(Sender: TObject);
begin
  yaw := seYaw.Value;
  RenderScene;
end;

procedure TForm1.sePitchChange(Sender: TObject);
begin
  pitch := sePitch.Value;
  RenderScene;
end;

procedure TForm1.seRollChange(Sender: TObject);
begin
  roll := seRoll.Value;
  RenderScene;
end;

end.
