unit UnitKneeExtension;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, VclTee.TeeGDIPlus, Vcl.StdCtrls,
  VCLTee.Series, math, openGL, VCLTee.TeEngine, Vcl.ExtCtrls, VCLTee.TeeProcs, VCLTee.Chart,
  Vcl.Buttons, UnitEquation, UnitDiagram;

type
  TForm2 = class(TForm)
    Timer1: TTimer;
    Timer2: TTimer;
    SaveDialog1: TSaveDialog;
    ScrollBox1: TScrollBox;
    Chart1: TChart;
    Series1: TLineSeries;
    Chart10: TChart;
    Series11: TLineSeries;
    Chart11: TChart;
    Series12: TLineSeries;
    Chart2: TChart;
    Series2: TPointSeries;
    Chart3: TChart;
    Series3: TLineSeries;
    Chart4: TChart;
    Series4: TLineSeries;
    Chart5: TChart;
    Series5: TLineSeries;
    Chart6: TChart;
    Series6: TLineSeries;
    Chart7: TChart;
    Series7: TLineSeries;
    Series8: TLineSeries;
    Chart8: TChart;
    Series9: TPointSeries;
    Chart9: TChart;
    Series10: TLineSeries;
    GroupBox1: TGroupBox;
    Label1: TLabel;
    Label2: TLabel;
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Edit1: TEdit;
    Edit2: TEdit;
    Button4: TButton;
    BitBtn1: TBitBtn;
    GroupBox2: TGroupBox;
    Label3: TLabel;
    Label4: TLabel;
    Label5: TLabel;
    Label6: TLabel;
    Label7: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    Edit3: TEdit;
    Edit4: TEdit;
    Edit5: TEdit;
    Edit6: TEdit;
    Edit7: TEdit;
    Edit8: TEdit;
    Edit9: TEdit;
    PanelGL: TPanel;
    ListBox1: TListBox; // Added ListBox for f(l)
    ListBox2: TListBox;
    ButtonShowEquation: TButton;
    ButtonShowDiagram: TButton; // Added ListBox for f(v)
    procedure single_pend_equ(thetaa,thetadota,phia,phidota:real) ;
    procedure rungekutta_single(thetab,thetadotb,phib,phidotb:real);
    procedure tes(tr,tf:real);
    procedure FormDestroy(Sender: TObject);
    procedure render2;
    procedure render;
    procedure SaveDataToFile(FileNamePrefix, variabelname: string; ValueArray: TArray<Double>);
    procedure FormResize(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure Timer2Timer(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure PanelGLResize(Sender: TObject);
    procedure ButtonShowDiagramClick(Sender: TObject);
  private
    { Private declarations }
  myDC : HDC;
  myRC : HGLRC;
  myPalette : HPALETTE;
  procedure SetupPixelFormat;
  public
    { Public declarations }
  end;

const
  mat_specular : array [0..3] of GLfloat = ( 8.0, 8.0, 1.0, 0.0 );
  mat_shininess : GLfloat = 40.0;
  light_position : array [0..3] of GLfloat = ( 120.6, 14.0, 41.0, 10.7 );
//  ck=10.0;
//  k1k=6.1;
//  k2k=5.9;
//  k3k=10.5;
//  k4k=21.8;
//  phi1k=10;
//  phi2k=67;

var
  Form2: TForm2;
  Sphere,cylinder,disk,partialdisk: GLUquadricObj;
  zpos,xpos,ypos:real;
  u:real;
  rotangle1,rotangle2,rotangle3,rotangle4,rotangle5,rotanglee,rotangleee:real;
  Mlambo,Mball,length:integer;
  m,bw,bh,force,grav,inertia,lgth: real;

  thetadotdot,thetadot,theta,phidotdot,phidot,phi:real;
  thetadotdot2,thetadot2,theta2,phidotdot2,phidot2,phi2:real;
  k1,k2,k3,k4,dt,k11,k21,k31,k41:real;
  torque,torque1,lopt, vmax:real;
  extention : boolean;

  adot,act,tf,tr,k1a,k2a,k3a,k4a:real;
  adot1,act1,tf1,tr1:real;
  counter,time, g:integer;
  activ1,activ, c: array[-10000..10000] of extended;
  rotangle, vel,  fmusl, fmusv: TArray<Double>;
  fv,s:real;
  fmus, gravtorque, torsi:real;

implementation

{$R *.dfm}

procedure glBindTexture(target: GLenum; texture: GLuint); stdcall; external opengl32;

procedure tForm2.single_pend_equ(thetaa,thetadota,phia,phidota:real);
var  c, k1, k2, k3, k4, phi1, phi2: Real;
begin
  c := StrToFloat(Edit4.Text);
  k1 := StrToFloat(Edit3.Text);
  k2 := StrToFloat(Edit5.Text);
  k3 := StrToFloat(Edit6.Text);
  k4 := StrToFloat(Edit7.Text);
  phi1 := StrToFloat(Edit8.Text);
  phi2 := StrToFloat(Edit9.Text);

if extention then
begin
torque := (-c*thetadota)+k1*exp(-k2*(thetaa-phi1*pi/180))-k3*exp(-k4*(-thetaa + phi2 * pi/180));
thetadotdot2:=(torque*pi/180+(m*sqr(lgth)/8*phidota*phidota*2*sin(thetaa)*cos(thetaa))
-((m*grav*lgth/2*sin(thetaa))))/((m*sqr(lgth)/4)+Inertia);
phidotdot2:=(-1*(m*sqr(lgth)*phidota*thetadota*sin(thetaa)*cos(thetaa)/4))/(m*sqr(lgth))*2*sqr(sin(thetaa)/4);
end
else
torque := ((-c*thetadota)+k1*exp(-k2*(thetaa-phi1*pi/180))-k3*exp(-k4*(phi2*pi/180-thetaa))+Fmus*0.025)*1;
thetadotdot2:=(fmus+torque*pi/180+(m*sqr(lgth)/8*phidota*phidota*2*sin(thetaa)*cos(thetaa))
-((m*grav*lgth/2*sin(thetaa))))/((m*sqr(lgth)/4)+Inertia);
phidotdot2:=(-1*(m*sqr(lgth)*phidota*thetadota*sin(thetaa)*cos(thetaa)/4))/(m*sqr(lgth))*2*sqr(sin(thetaa)/4);
end;

procedure TForm2.Button1Click(Sender: TObject);
begin
extention := false;
  theta2:=0*pi/180;
  phi2:=0*pi/180;
  thetadot2:=0;
  phidot2:=0;
  if (not timer1.Enabled) then
  begin
   Series1.Clear; Series2.Clear; Series3.Clear; Series4.Clear; Series5.Clear; Series6.Clear;
   Series7.Clear; Series8.Clear; Series9.Clear; Series10.Clear;  Series11.Clear; Series12.Clear;
   // Clear ListBoxes when simulation starts
   ListBox1.Clear;
   ListBox2.Clear;

    timer1.enabled:=true;
    timer2.Enabled:=false;
    button1.caption:='Stop';
  end else
  begin
    timer1.enabled:=false;
    timer2.Enabled:=false;
    button1.caption:='Extension';
    time:=0;
    theta2:=60*pi/180;
    phi2:=60*pi/180;
    thetadot2:=0;
    phidot2:=0;
  end;
end;

procedure TForm2.Button2Click(Sender: TObject);
begin
  //dt:=0.01;
  fmus:=0;
  theta2:=90*pi/180;
  phi2:=90*pi/180;
  thetadot2:=0;
  phidot2:=0;

  if (not timer2.enabled) then
  begin
    Series1.Clear; Series2.Clear; Series3.Clear; Series4.Clear; Series5.Clear; Series6.Clear;
    Series7.Clear; Series8.Clear; Series9.Clear; Series10.Clear; Series11.Clear; Series12.Clear;
    // Clear ListBoxes for passive mode (though they won't be populated)
    ListBox1.Clear;
    ListBox2.Clear;

    timer1.enabled:=true;
    timer2.enabled:=true;
    button2.caption:='Stop';
  end else
  begin
    timer1.enabled:=false;
    timer2.enabled:=false;
    button2.caption:='Passive';
    //time:=0;
    theta2:=60*pi/180;
    phi2:=60*pi/180;
    thetadot2:=0;
    phidot2:=0;
  end;
end;

procedure TForm2.Button3Click(Sender: TObject);
begin
  Series1.Clear; Series2.Clear; Series3.Clear; Series4.Clear; Series5.Clear; Series6.Clear;
  Series7.Clear; Series8.Clear; Series9.Clear; Series10.Clear; Series11.Clear; series12.Clear;
  // Clear ListBoxes on Reset
  ListBox1.Clear;
  ListBox2.Clear;
  Timer1.Enabled:=false;
  timer2.enabled:=false;
end;

procedure TForm2.Button4Click(Sender: TObject);
var
  SaveFile: TextFile;
  FileName: string;
  i, j: Integer;
  Charts: array[1..11] of TChart; // Array untuk menyimpan referensi chart
  SeriesData: TChartSeries;
begin
  // Inisialisasi array Charts
  Charts[1] := Chart1;
  Charts[2] := Chart2;
  Charts[3] := Chart3;
  Charts[4] := Chart4;
  Charts[5] := Chart5;
  Charts[6] := Chart6;
  Charts[7] := Chart7;
  Charts[8] := Chart8;
  Charts[9] := Chart9;
  Charts[10] := Chart10;
  Charts[11] := Chart11;

  // Tampilkan dialog untuk memilih nama file
  if SaveDialog1.Execute then
  begin
    FileName := SaveDialog1.FileName;

    // Tambahkan ekstensi .txt jika belum ada
    if ExtractFileExt(FileName) = '' then
      FileName := FileName + '.txt';

    // Membuka file untuk ditulis
    AssignFile(SaveFile, FileName);
    Rewrite(SaveFile);

    try
      // Iterasi melalui setiap chart dan series
      for i := 1 to 11 do
      begin
        // Validasi chart tidak nil
        if Assigned(Charts[i]) then
        begin
          if Charts[i].SeriesCount > 0 then
          begin
            SeriesData := Charts[i].Series[0]; // Ambil series pertama dari setiap chart

            // Tulis header untuk series
            Writeln(SaveFile, 'Chart ', i, ' - Series: ', SeriesData.Title);

            // Tulis data point (X dan Y)
            for j := 0 to SeriesData.Count - 1 do
            begin
              Writeln(SaveFile, Format('X: %.4f, Y: %.4f',
                [SeriesData.XValue[j], SeriesData.YValue[j]]));
            end;

            Writeln(SaveFile); // Tambahkan baris kosong antar chart
          end
          else
            Writeln(SaveFile, 'Chart ', i, ' - Series: Tidak ada data'); // Jika series kosong
        end
        else
          Writeln(SaveFile, 'Chart ', i, ' tidak valid.'); // Jika chart tidak valid
      end;

      ShowMessage('Data berhasil disimpan ke ' + FileName);
    finally
      CloseFile(SaveFile);
    end;
  end;
end;

procedure TForm2.ButtonShowDiagramClick(Sender: TObject);
begin
  if Assigned(FormDiagram) then
    FormDiagram.Show;
end;

procedure TForm2.FormCreate(Sender: TObject);
begin
  timer1.enabled:=false;
  timer2.enabled:=false;
  setlength(fmusl, 10000);
  setlength(fmusv, 10000);
  setlength(rotangle, 10000);
  setlength(vel, 10000);
  act:=1;
  g := 0;
  lopt:=0.48;
  vmax:=1.35;
  button1.caption:='Extention';
  button2.caption:='Passive';
  dt := 0.01;
  rotangle [g] := 0;
  BW:=StrToFloat(Edit1.Text);  //berat
  BH:=StrToFloat(Edit2.Text); //tinggi
  grav:=9.8;
  lgth:=0.407*BH/160;
  m := 2.76*BW/60;
  inertia := (1 / 3) * m * sqr(Lgth);
  //inertia:=(m*sqr(lgth)/12)+(m*sqr(lgth/2));

  //Form2.myDC:= GetDC(Handle);
  Form2.myDC := GetDC(PanelGL.Handle);
  SetupPixelFormat;
  myRC:= wglCreateContext(myDC);
  wglMakeCurrent(myDC, myRC);
  glEnable(GL_DEPTH_TEST);
  glLoadIdentity;

  glClearColor(0.0, 0.0, 0.0, 1.0);
  glShadeModel(GL_SMOOTH);                 // Enables Smooth Color Shading
  glClearDepth(1.0);                       // Depth Buffer Setup
  glEnable(GL_DEPTH_TEST);                 // Enable Depth Buffer
  glDepthFunc(GL_LESS);		           // The Type Of Depth Test To Do

  glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

  glEnable(GL_TEXTURE_2D);

  Sphere := gluNewQuadric();
  cylinder:= gluNewQuadric();
  disk:=glunewquadric();
  partialdisk:=glunewquadric();
  gluQuadricNormals(Sphere, GLU_SMOOTH);   // Create Smooth Normals
  gluQuadricNormals(cylinder, GLU_SMOOTH);   // Create Smooth Normals
  gluQuadricNormals(disk, GLU_SMOOTH);   // Create Smooth Normals

  glMaterialfv(GL_FRONT, GL_SPECULAR, @mat_specular);
  glMaterialfv(GL_BACK, GL_SPECULAR, @mat_specular);
  glMaterialfv(GL_FRONT, GL_SHININESS, @mat_shininess);
  glMaterialfv(GL_BACK, GL_SHININESS, @mat_shininess);
  glLightfv(GL_LIGHT0, GL_POSITION, @light_position);
  glLightfv(GL_LIGHT3, GL_SPECULAR, @mat_specular);
  glLightfv(GL_LIGHT1, GL_POSITION, @light_position);
  glLightfv(GL_LIGHT2, GL_POSITION, @light_position);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);
  glEnable(GL_LIGHT2);
  glEnable(GL_LIGHT3);
  glDepthFunc(GL_LEQUAL);

  xpos:=-5.0;
  zpos:=-20.0;
  ypos:=0.0;

  // Clear listboxes initially
  ListBox1.Clear;
  ListBox2.Clear;
end;

procedure TForm2.FormDestroy(Sender: TObject);
begin
  wglmakecurrent(0,0);
  wgldeletecontext(mydc);
  //releasedc(handle,mydc);

  ReleaseDC(PanelGL.Handle, myDC);
end;

{procedure TForm2.FormResize(Sender: TObject);
begin
  glViewport(0, 0, Width, Height);    // Setzt den Viewport für das OpenGL Fenster
  glMatrixMode(GL_PROJECTION);        // Matrix Mode auf Projection setzen
  glLoadIdentity();                   // Reset View
  gluPerspective(45.0, Width/Height, 1, 100.0);  // Perspektive den neuen Maßen anpassen.
  glMatrixMode(GL_MODELVIEW);         // Zurück zur Modelview Matrix
  glLoadIdentity();
end;}

procedure TForm2.FormResize(Sender: TObject);
begin
  // Pastikan PanelGL sudah dibuat (safety check)
  if (PanelGL = nil) then Exit;

  // UBAH SEMUA REFERENSI Width/Height menjadi PanelGL.Width/Height
  glViewport(0, 0, PanelGL.Width, PanelGL.Height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  // Perhatikan pembagiannya: PanelGL.Width / PanelGL.Height
  if PanelGL.Height = 0 then
    gluPerspective(45.0, PanelGL.Width, 1, 100.0) // Mencegah divide by zero
  else
    gluPerspective(45.0, PanelGL.Width / PanelGL.Height, 1, 100.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
end;

procedure TForm2.PanelGLResize(Sender: TObject);
begin
  glViewport(0, 0, PanelGL.Width, PanelGL.Height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  if PanelGL.Height > 0 then
    gluPerspective(45.0, PanelGL.Width / PanelGL.Height, 1, 100.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
end;

procedure TForm2.rungekutta_single(thetab,thetadotb,phib,phidotb:real);
var
  k1,k2,k3,k4,k11,k21,k31,k41:real;
begin
  single_pend_equ(thetab,thetadotb,phib,phidotb);
  k1:=0.5*dt*thetadotdot2;
  k11:=0.5*dt*phidotdot2;

  single_pend_equ(thetab+0.5*dt*(thetadotb+0.5*k1),thetadotb+k1,phib+0.5*dt*(phidotb+0.5*k11),phidotb+k11);
  k2:=0.5*dt*thetadotdot2;
  k21:=0.5*dt*phidotdot2;

  single_pend_equ(thetab+0.5*dt*(thetadotb+0.5*k1),thetadotb+k2,phib+0.5*dt*(phidotb+0.5*k11),phidotb+k21);
  k3:=0.5*dt*thetadotdot2;
  k31:=0.5*dt*phidotdot2;

  single_pend_equ(thetab+dt*(thetadotb+k3),thetadotb+2*k3,phib+dt*(phidotb+k31),phidotb+2*k31);
  k4:=0.5*dt*thetadotdot2;
  k41:=0.5*dt*phidotdot2;

  theta2:=theta2+dt*(thetadot2+1/3*(k1+k2+k3));
  thetadot2:=thetadot2+1/3*(k1+2*k2+2*k3+k4);

  phi2:=phi2+dt*(phidot2+1/3*(k11+k21+k31));
  phidot2:=phidot2+1/3*(k11+2*k21+2*k31+k41);
end;

procedure recruitment(s1:extended);
begin
  u:= 0.5*tanh(15*(s1-0.5))+0.5;
end;

procedure tForm2.tes(tr,tf:real);
begin
  tr :=100;
  tf :=150;

  recruitment(time);
  adot:=1/tr*(u-act)*u+1/tf*(u-act-(u-act)*u);
    k1a:=dt*adot;
    act:=act+0.5*k1a;
    adot:= 1/tr*(u-act)*u+1/tf*(u-act-(u-act)*u);
    k2a:=dt*adot;
    act:=act+0.5*k2a;
    adot:=1/tr*(u-act)*u+1/tf*(u-act-(u-act)*u);
    k3a:=dt*adot;
    act:=act+k3a;
    adot:=1/tr*(u-act)*u+1/tf*(u-act-(u-act)*u);
    k4a:=dt*adot;
   activ[time]:=activ[time-1]+1/6*(k1a+2*k2a+2*k3a+k4a);
   act:=activ[time];
end;

{procedure TForm2.Timer1Timer(Sender: TObject);
begin
  render;
  time:=time+ 1;
  c[g] := time;
  inc(g);
  rungekutta_single(theta2, thetadot2, phi2, phidot2);
  rotangle[g] := theta2 * 180 / pi;  // Sudut rotasi dalam derajat
  vel[g] := sqrt(sqr(lgth) / 4 * (sqr(thetadot2) + sqr(phidot2) * sqr(sin(theta2))));
  gravtorque:=m*grav*(lgth-lgth/2*cos(theta2));

  Series4.AddXY(time/60, gravtorque);
  Series12.AddXY(time / 60, 90-rotangle[g]);  // sudut kaki
  series6.AddXY(time / 60, rotangle[g]);
  Series11.AddXY(time / 60, vel[g]);
  Series5.AddXY(time/60,torque);
   if rotangle[g] >=88 then
    begin
      rotangle[g]:=88;
      //timer1.enabled:=false;
      //timer2.enabled:=false;
      //showmessage('done');
      extention := true;
    end;
  if not extention then
    begin
      tes(1, 1);
      Series7.AddXY(time / 60, activ[time]);
      Series8.AddXY(time / 60, u);

    //force-length relationship
    Fmusl[g] :=  (1.0 - sqr((0.025 * theta2) /( 0.5 *Lopt)));
    if (Fmusl[g] < 0.0) then Fmusl[g] := 0.0;

    // Add f(l) value to ListBox1
    ListBox1.Items.Add(Format('%.4f', [Fmusl[g]]));

    //Series6.AddXY( Lopt -theta2 * (0.72 - Lopt), Fmusl[g]);
    Series10.AddXY(Lopt -theta2 * (0.72 - Lopt), Fmusl[g]);
    Series1.AddXY(time/60,Lopt -theta2 * (0.72 - Lopt));
    Series3.AddXY(time/60,fmus);

    //multiply by force-velocity relationship
    Fmusv[g] :=  (vmax - thetadot2) / (vmax + 2.5 * thetadot2);
    if (Fmusv[g] < 0.0) then Fmusv[g]  := 0.0;

    // Add f(v) value to ListBox2
    ListBox2.Items.Add(Format('%.4f', [Fmusv[g]]));

    Series9.AddXY(-vel[g], Fmusv[g]);
    Series2.AddXY(-vel[g], Lopt -theta2 * (0.72 - Lopt));

    Fmus := Fmusv[g]* activ[time]*1800*Fmusl[g];
   end;
end;}

procedure TForm2.Timer1Timer(Sender: TObject);
begin
  render;
  time:=time+ 1;
  c[g] := time;
  inc(g);
  rungekutta_single(theta2, thetadot2, phi2, phidot2);
  rotangle[g] := theta2 * 180 / pi;  // Sudut rotasi dalam derajat
  vel[g] := sqrt(sqr(lgth) / 4 * (sqr(thetadot2) + sqr(phidot2) * sqr(sin(theta2))));
  gravtorque:=m*grav*(lgth-lgth/2*cos(theta2));

  Series4.AddXY(time/60, gravtorque);
  Series12.AddXY(time / 60, 90-rotangle[g]);  // sudut kaki
  series6.AddXY(time / 60, rotangle[g]);
  Series11.AddXY(time / 60, vel[g]);
  Series5.AddXY(time/60,torque);
   if rotangle[g] >=88 then
    begin
      rotangle[g]:=88;
      //timer1.enabled:=false;
      //timer2.enabled:=false;
      //showmessage('done');
      extention := true;
    end;
  if not extention then
    begin
      tes(1, 1);
      Series7.AddXY(time / 60, activ[time]);
      Series8.AddXY(time / 60, u);

    {force-length relationship}
    Fmusl[g] :=  (1.0 - sqr((0.025 * theta2) /( 0.5 *Lopt)));
    if (Fmusl[g] < 0.0) then Fmusl[g] := 0.0;

    // --- MODIFIED SECTION FOR F(L) ---
    // Now prints: "F(L)[index]: Value"
    ListBox1.Items.Add(Format('Length: %.5f - F(L)[%d]: %.4f', [Lopt -theta2 * (0.72 - Lopt), g, Fmusl[g]]));
    // ---------------------------------

    //Series6.AddXY( Lopt -theta2 * (0.72 - Lopt), Fmusl[g]);
    Series10.AddXY(Lopt -theta2 * (0.72 - Lopt), Fmusl[g]);
    Series1.AddXY(time/60,Lopt -theta2 * (0.72 - Lopt));
    Series3.AddXY(time/60,fmus);

    {multiply by force-velocity relationship}
    Fmusv[g] :=  (vmax - thetadot2) / (vmax + 2.5 * thetadot2);
    if (Fmusv[g] < 0.0) then Fmusv[g]  := 0.0;

    // --- MODIFIED SECTION FOR F(V) ---
    // Now prints: "F(V)[index]: Value"
    ListBox2.Items.Add(Format('Velocity: %.5f - F(V)[%d]: %.4f', [-vel[g], g, Fmusv[g]]));
    // ---------------------------------

    Series9.AddXY(-vel[g], Fmusv[g]);
    Series2.AddXY(-vel[g], Lopt -theta2 * (0.72 - Lopt));

    Fmus := Fmusv[g]* activ[time]*1800*Fmusl[g];
   end;
end;

procedure TForm2.Timer2Timer(Sender: TObject);
begin
  extention := true;
  render;  //passive
  time:=time+1;
//  rungekutta_single(theta2,thetadot2,phi2,phidot2);
//  rotangle[g]:=theta2*180/pi;
//  vel[g]:= sqrt(sqr(lgth)/4*(sqr(thetadot2)+sqr(phidot2)*sqr(sin(theta2))));
//  Series1.addxy(time/60,rotangle[g]);
//  Series5.addxy(time/60,vel[g]);
end;

procedure TForm2.SaveDataToFile(FileNamePrefix, variabelname: string;  ValueArray: TArray<Double>);
var
  SaveFile: TextFile;
  FileName: string;
  i: Integer;
begin
  // Konfigurasi SaveDialog
  SaveDialog1.Filter := 'Text File (.txt)|.txt|CSV File (.csv)|.csv';
  SaveDialog1.DefaultExt := 'txt';
  SaveDialog1.FileName := FileNamePrefix + '.txt'; // Set nama default file

  // Menampilkan dialog penyimpanan
  if SaveDialog1.Execute then
  begin
    FileName := SaveDialog1.FileName;
    AssignFile(SaveFile, FileName);

    // Coba buka file untuk menulis
    try
      Rewrite(SaveFile);

      // Tulis header (opsional)
      WriteLn(SaveFile, 'Time (s),|' +variabelname);

      // Simpan nilai time dan nilai Y dari array
      for i := 0 to g do
      begin
        // Pastikan kedua array memiliki panjang yang sama
        if i <= High(ValueArray) then
          WriteLn(SaveFile, Format('%f' + #9 + '%f', [c[i], ValueArray[i]]));
      end;

      ShowMessage(FileNamePrefix + ' berhasil disimpan!');
    finally
      // Tutup file
      CloseFile(SaveFile);
    end;
  end
  else
  begin
    ShowMessage('Penyimpanan dibatalkan.');
  end;
end;

// 3D VISUALIZATION
{procedure tForm2.render;
begin
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT); //Farb und Tiefenpuffer löschen
  glLoadIdentity;

  gltranslate(xpos,ypos,zpos);
 glrotate(90,0,0,1);

 //glenable(gl_lighting);
 glrotate(90,1,0,0);// rotate around y  x-z axis coronal or transversal plane
 glrotate(0,0,1,0);
 glrotate(0,1,0,0);  //sendi paha
 gluSphere(Sphere,0.9,21,21);
 gluCylinder(cylinder, 0.8, 0.55, 5, 32, 32);

 gltranslate(0,0,5);
 glrotate(rotangle[g],0,1,0);  //sendi lutut
 glrotate(0,1,0,0);    //pergelangan kaki  (muter roll)
 gluSphere(Sphere,0.6,20,20);
 glrotate(-90,0,1,0);
 gluCylinder(cylinder, 0.55, 0.4, 5, 32, 32);

 gltranslate(0,0,5);
 gluSphere(Sphere,0.5,20,20);

 gltranslate(0,0,0);
 gluSphere(Sphere,0.5,20,20);
 glrotate(90,0,1,0);  //pergelangan kaki tp yaw
 gluCylinder(cylinder, 0.5, 0.15, 1.5, 32, 32);

swapBuffers(Form2.myDC);
end;}

// 2D VISUALIZATION
procedure TForm2.render;
begin
  // 1. Bersihkan layar
  glClearColor(0.0, 0.0, 0.0, 1.0); // Background Hitam
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadIdentity;

  // 2. Setup Mode 2D
  glDisable(GL_LIGHTING);
  glDisable(GL_TEXTURE_2D);
  glEnable(GL_POINT_SMOOTH);

  // 3. Posisikan Kamera
  glTranslate(xpos, ypos, zpos);

  // --- BAGIAN 1: PAHA (THIGH) ---
  // A. Sendi Hip (Pangkal Paha)
  glPointSize(20.0);
  glColor3f(0.0, 0.0, 1.0); // Biru
  glBegin(GL_POINTS);
    glVertex3f(0.0, 0.0, 0.0);
  glEnd;

  // B. Tulang Paha
  glLineWidth(10.0);
  glColor3f(1.0, 0.0, 0.0); // Merah
  glBegin(GL_LINES);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(5.0, 0.0, 0.0);  // Panjang Paha 5 unit
  glEnd;

  // --- BAGIAN 2: BETIS (SHANK) ---
  // Pindah ke Lutut
  glTranslate(5.0, 0.0, 0.0);

  // C. Sendi Lutut (Knee)
  glColor3f(0.0, 0.0, 1.0); // Biru
  glBegin(GL_POINTS);
    glVertex3f(0.0, 0.0, 0.0);
  glEnd;

  // D. Rotasi Betis (Sesuai simulasi)
  glRotate(rotangle[g] - 90, 0.0, 0.0, 1.0);

  // E. Tulang Betis
  glColor3f(1.0, 0.0, 0.0); // Merah
  glBegin(GL_LINES);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(5.0, 0.0, 0.0);  // Panjang Betis 5 unit
  glEnd;

  // --- BAGIAN 3: TELAPAK KAKI (FOOT) ---
  // Pindah ke Ankle
  glTranslate(5.0, 0.0, 0.0);

  // F. Sendi Ankle
  glColor3f(0.0, 0.0, 1.0); // Biru
  glBegin(GL_POINTS);
    glVertex3f(0.0, 0.0, 0.0);
  glEnd;

  // G. Rotasi Telapak Kaki
  // Kita putar 90 derajat agar telapak kaki tegak lurus terhadap betis
  glRotate(90.0, 0.0, 0.0, 1.0);

  // H. Tulang Telapak Kaki
  glColor3f(1.0, 0.0, 0.0); // Merah
  glBegin(GL_LINES);
    glVertex3f(0.0, 0.0, 0.0);
    glVertex3f(2.0, 0.0, 0.0);  // Panjang Kaki 2 unit (lebih pendek dari paha/betis)
  glEnd;

  {glTranslate(2.0, 0.0, 0.0);
  glColor3f(0.0, 0.0, 1.0);
  glBegin(GL_POINTS);
    glVertex3f(0.0, 0.0, 0.0);
  glEnd;}

  SwapBuffers(Form2.myDC);
end;

procedure tform2.render2;
var
i:integer;
te1:real;
begin
  glClearColor(0.15, 0.8, 0.8, 0.0);
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT); //Farb und Tiefenpuffer löschen
  glLoadIdentity;

  gltranslate(xpos,ypos,zpos);
 glrotate(90,0,0,1);

 //glenable(gl_lighting);
 glrotate(90,1,0,0);// rotate around y  x-z axis coronal or transversal plane
 glrotate(0,0,1,0);
 glrotate(0,1,0,0);  //sendi paha
 gluSphere(Sphere,0.8,20,20);
 gluCylinder(cylinder, 0.8, 0.55, 5, 32, 32);

 gltranslate(0,0,5);
 glrotate(rotangle[g],0,1,0);  //sendi lutut
 glrotate(0,1,0,0);    //pergelangan kaki  (muter roll)
 gluSphere(Sphere,0.6,20,20);
 glrotate(-90,0,1,0);
 gluCylinder(cylinder, 0.55, 0.4, 5, 32, 32);

 gltranslate(0,0,5);
 gluSphere(Sphere,0.5,20,20);

 gltranslate(0,0,0);
 gluSphere(Sphere,0.5,20,20);
 glrotate(90,0,1,0);  //pergelangan kaki tp yaw
 gluCylinder(cylinder, 0.5, 0.2, 1.5, 32, 32);

 swapBuffers(form2.myDC);
end;

procedure TForm2.SetupPixelFormat;
var    hHeap: THandle;
  nColors, i: Integer;
  lpPalette : PLogPalette;
  byRedMask, byGreenMask, byBlueMask: Byte;
  nPixelFormat: Integer;
  pfd: TPixelFormatDescriptor;
begin
  FillChar(pfd, SizeOf(pfd), 0);
  with pfd do begin
    nSize     := sizeof(pfd);               // Länge der pfd-Struktur
    nVersion  := 1;                         // Version
    dwFlags   := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or
                 PFD_DOUBLEBUFFER;          // Flags
    iPixelType:= PFD_TYPE_RGBA;             // RGBA Pixel Type
    cColorBits:= 32;                        // 24-bit color
    cDepthBits:= 32;                        // 32-bit depth buffer
    iLayerType:= PFD_MAIN_PLANE;            // Layer Type
  end;
  nPixelFormat:= ChoosePixelFormat(myDC, @pfd);
  SetPixelFormat(myDC, nPixelFormat, @pfd);
                                            // Farbpalettenoptimierung wenn erforderlich
  DescribePixelFormat(myDC, nPixelFormat,
                      sizeof(TPixelFormatDescriptor),pfd);
  if ((pfd.dwFlags and PFD_NEED_PALETTE) <> 0) then begin
    nColors  := 1 shl pfd.cColorBits;
    hHeap    := GetProcessHeap;
    lpPalette:= HeapAlloc
       (hHeap,0,sizeof(TLogPalette)+(nColors*sizeof(TPaletteEntry)));
    lpPalette^.palVersion := $300;
    lpPalette^.palNumEntries := nColors;
    byRedMask  := (1 shl pfd.cRedBits) - 1;
    byGreenMask:= (1 shl pfd.cGreenBits) - 1;
    byBlueMask := (1 shl pfd.cBlueBits) - 1;
   for i := 0 to nColors - 1 do
   begin
      lpPalette^.palPalEntry[i].peRed  :=
        (((i shr pfd.cRedShift)  and byRedMask)  *255)DIV byRedMask;
      lpPalette^.palPalEntry[i].peGreen:=
        (((i shr pfd.cGreenShift)and byGreenMask)*255)DIV byGreenMask;
      lpPalette^.palPalEntry[i].peBlue :=
        (((i shr pfd.cBlueShift) and byBlueMask) *255)DIV byBlueMask;
      lpPalette^.palPalEntry[i].peFlags:= 0;
    end;
    myPalette:= CreatePalette(lpPalette^);
    HeapFree(hHeap, 0, lpPalette);
    if (myPalette <> 0) then
    begin
      SelectPalette(myDC, myPalette, False);
      RealizePalette(myDC);
    end;
  end;
end;
end.
